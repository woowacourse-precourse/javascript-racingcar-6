## 🚀 기능 구현 목록

### 1. 자동차 기능과 게임 실행 기능으로 나눈다.
#### 🥕 자동차 기능
```
  1. 자동차는 이름을 갖는다.
  2. 자동차는 전진 횟수를 갖는다.
    a. 자동차의 전진 횟수를 반환할 수 있다.
  3. 자동차는 랜덤하게 0에서 9 사이에서 무작위 값을 구한다.
    a. 자동차가 움직일 수 있는 숫자라면 자동차의 전진 횟수를 1만큼 증가시킨다.
  4. 자동차의 이름과 전진 횟수를 출력한다.
    a. 전진 횟수는 숫자가 아닌 붙임표(-) 기호의 갯수를 통해 출력한다.
```
#### 🥕 게임 실행 기능
```
  1. 사용자로부터 자동차의 이름을 입력 받는다.
    a. 자동차의 이름을 쉼표(,)를 통해 구분한다.
    b. 자동차의 이름은 5글자 이하로 유효하다.
      i. 5글자를 초과한 이름에 대해 에러를 반환하며 프로그램을 종료한다.
      ii. 유효한 자동차 이름에 대해 자동차 기능 개체를 통해 각 자동차를 생성한다.
  2. 사용자로부터 경주 횟수를 입력 받는다.
    a. 경주 횟수는 1 이상의 숫자로 유효하다.
      i. 1 미만의 숫자 혹은 숫자가 아닌 입력값에 대해 에러를 반환하며 프로그램을 종료한다.
  3. 경주 횟수만큼 레이싱을 한다.
    a. 각 자동차에서 자동차 3번 기능을 실행한다.
    b. 각 자동차에서 자동차 4번 기능을 통해 결과를 출력한다.
  4. 우승 자동차를 출력한다.
    a. 전체 자동차의 전진 횟수를 비교하여 가장 큰 전진 횟수를 찾는다.
    b. 가장 큰 전진 횟수를 가진 자동차의 이름을 모두 찾아 출력한다.
```
### 2. 각 세부 기능별 테스트 코드를 작성한다.
**이 때 각 세부 기능에 성공, 엣지 케이스를 하나씩 테스트한다.**
#### 🥕 레이싱 테스트
```
  1. 자동차 생성 테스트
    a. 유효한 이름으로 자동차 생성
    b. 자동차의 갯수가 0개일 시 오류 반환
  2. 자동차 이름 유효성 테스트
    a. 빈 문자열 입력 시 오류 반환
    b. 5글자 초과 시 오류 반환
    c. 중복된 자동차 이름 입력 시 오류 반환
    d. 유효한 문자열 입력 시 오류 미반환
  3. 경주 횟수 유효성 테스트
    a. 입력된 시도 횟수가 숫자가 아닐 시 오류 반환
    b. 입력된 시도 횟수가 1 미만인 숫자일 경우 오류 반환
    c. 올바른 시도 횟수 입력 시 해당 문자열을 숫자 타입으로 반환
  4. 경주 사이클 테스트
    a. 경주 시 실행 결과 메시지 및 각 자동차 별 포지션 반환
  5. 우승자 찾기 테스트
    a. 현재 포지션에 따른 우승 자동차 출력
    b. 공동 우승시 우승 자동차 모두 출력
    c. 우승 자동차 포지션이 시작점일 경우 오류 반환
  6. 우승자 출력 테스트
    a. 정상적인 우승자 출력
    b. 우승자 배열이 비어있을 경우 오류 반환
```

**예외(에러) 케이스가 발생할 수 있는 함수의 경우 예외 케이스를 테스트한다.**
#### 
---
## TIL (공부해야할 부분 && 알게된 부분)

#### 1. `indent depth <= 2` 규칙이 추가되었다.

이 부분을 보니 모듈화를 필수적으로 해야하고 이 부분이 JS에서 어떠한 장점으로 다가오는지 확인해보았다.
각 함수가 기능을 맡으며 단일 책임 원칙을 가져 가독성, 유지보수성, 테스팅 신뢰성, 재사용성 등을 확보할 수 있다.

무엇보다 이번 과제에서 중요한 것은 각 기능 함수별 test 코드를 작성하는 것이라고 생각하고
기능별로 각 함수를 분할한 후 함수마다 테스팅 할 수 있도록 작성하기로 했다.

#### 2. 자동차를 Class로 구현할 생각이다.

지난 주 과제에서는 각 함수를 기능별 구분에 따라 파일로 나누었는데 아직 다른 부분은 몰라도 자동차에 대해선 Class로 구현하는 것이 효율적일 것 같다.

그 이유는 다음과 같다.

1. 자동차는 개체로 표현될 수 있고 Class로 모델링하기 적합하다.
2. 각 자동차가 가져야하는 데이터의 양식이 같다.
3. 각 자동차의 데이터에 따라 연산하는 기능을 Class에 메서드로 추가하며 반복적인 코드 작업이 불필요해진다.
4. 자동차에 대한 테스팅 시 클래스 단위로 테스트가 가능하다.

#### 3. 생각해볼만한 점
입력에 자동차가 1대 혹은 0대가 들어왔을 경우 => 1대의 경우 경주로 판단하기로 했다. 0대는 불가하도록 에러를 반환한다.
`poby,,jon` 과 같이 들어왔을 경우 => 
메일 내용처럼 JS 기본 API를 각 기능에 맞게 적재적소에 적극 활용하자 (Math, map, forEach 등)

과제에 명시되지 않은 부분을 어떻게 처리할지, 각 모듈화를 하고 테스트를 하며 이렇게 테스트를 할 수 있구나 TDD에 대한 이해와 깨달음을 얻는 중..
depth를 줄이기 위해 기본 JS 제공 메서드를 적극적으로 찾아보니 참 다양하게 좋은 함수들이 많다는 것을 알게됨

기능별로 책임이 분리된 모듈을 가지기 때문에 현재 전체 코드에서 일어나지 않을 오류 [ex) 결과 출력 시 빈배열] 들 또한 최대한 생각해서 test case를 만들어야겠다고 생각했다.
이후 각 모듈을 import 하거나 더 큰 프로젝트를 만들 떄 활용할 수 있도록 각 모듈에서 발생할 수 있는 예외적 case를 찾고자 노력했다.

또한 test 코드를 공부하며 jest 라이브러리를 처음 사용했는데 생각보다 테스트 할 수 있는 범위가 많아서 신기했고, 
test 코드를 직접 만들다 보니 확실히 내가 생각하지 못헀던 예외가 하나씩 떠오르기도 했다.

1주차에서는 play 메서드 외에서 에러를 직접 반환하여 프로그램을 종료하도록 만들었지만 이번엔 `[ERROR]`에 해당하는 메세지를 play에서 출력해주며 전체 에러에 대한 관리를
play 메서드를 통해 할 수 있게 하고자 하였다.

때문에 각각의 테스트 코드에서 출력하는 에러 메세지가 무엇인지 하나씩 대조하여 일치시켜줘야했지만, 추후 유지 보수, 확장에 있어 더 편리할 것 같다.
더 많은 에러 메세지를 생성한다고 해도 무조건 에러 헤더로 `[ERROR]` 메세지가 붙기 때문에 1주차 과제보다 조금 더 발전된 처리라고 생각했다.

